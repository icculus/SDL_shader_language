/* Generated by re2c 3.0 */
/**
 * SDL_shader_language; tools for SDL GPU shader support.
 *
 * Please see the file LICENSE.txt in the source's root directory.
 */

// This was originally based on examples/pp-c.re from re2c: https://re2c.org/
//   re2c is public domain code.
//
// You build mojoshader_lexer.c from the .re file with re2c...
// re2c -is -o mojoshader_lexer.c mojoshader_lexer.re
//
// Changes to the lexer are done to the .re file, not the C code!
//
// Please note that this isn't a perfect C lexer, since it is used for both
//  HLSL and shader assembly language, and follows the quirks of Microsoft's
//  tools (!!! FIXME: that was true for MojoShader, but we can fix anything
//  that pops up now).

#define __SDL_SHADER_INTERNAL__ 1
#include "SDL_shader_internal.h"

typedef unsigned char uchar;

#define YYMAXFILL 8

#define RET(t) return update_state(s, eoi, cursor, token, (Token) t)
#define YYCTYPE uchar
#define YYCURSOR cursor
#define YYLIMIT limit
#define YYMARKER s->lexer_marker
#define YYFILL(n) { if ((n) == 1) { cursor = sentinel; limit = cursor + YYMAXFILL; eoi = 1; } }

static uchar sentinel[YYMAXFILL];

static Token update_state(IncludeState *s, int eoi, const uchar *cur, const uchar *tok, const Token val)
{
    if (eoi) {
        s->bytes_left = 0;
        s->source = (const char *) s->source_base + s->orig_length;
        if ( (tok >= sentinel) && (tok < (sentinel+YYMAXFILL)) ) {
            s->token = s->source;
        } else {
            s->token = (const char *) tok;
        }
    } else {
        s->bytes_left -= (size_t) (cur - ((const uchar *) s->source));
        s->source = (const char *) cur;
        s->token = (const char *) tok;
    }
    s->tokenlen = (size_t) (s->source - s->token);
    s->tokenval = val;
    return val;
}

Token preprocessor_lexer(IncludeState *s)
{
    const uchar *cursor = (const uchar *) s->source;
    const uchar *token = cursor;
    const uchar *matchptr;
    const uchar *limit = cursor + s->bytes_left;
    int eoi = 0;



    // preprocessor directives are only valid at start of line.
    if (s->tokenval == ((Token) '\n')) {
        goto ppdirective;  // may jump back to scanner_loop.
    }

    // Microsoft's preprocessor (and GCC!) allows multiline comments
    //  before a preprocessor directive, even though C/C++
    //  doesn't. See if we've hit this case.
    if (s->tokenval == TOKEN_MULTI_COMMENT) {
        goto ppdirective;  // may jump back to scanner_loop.
    }

scanner_loop:
    if (YYLIMIT <= YYCURSOR) { YYFILL(1); }
    token = cursor;


{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
	switch (yych) {
		case 0x00: goto yy1;
		case '\t':
		case '\v':
		case '\f':
		case ' ': goto yy4;
		case '\n': goto yy5;
		case '\r': goto yy7;
		case '!': goto yy8;
		case '"': goto yy9;
		case '#': goto yy10;
		case '%': goto yy11;
		case '&': goto yy12;
		case '\'': goto yy13;
		case '(': goto yy14;
		case ')': goto yy15;
		case '*': goto yy16;
		case '+': goto yy17;
		case ',': goto yy18;
		case '-': goto yy19;
		case '.': goto yy20;
		case '/': goto yy22;
		case '0': goto yy23;
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy25;
		case ':': goto yy27;
		case ';': goto yy28;
		case '<': goto yy29;
		case '=': goto yy31;
		case '>': goto yy32;
		case '?': goto yy34;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy35;
		case '[': goto yy37;
		case '\\': goto yy38;
		case ']': goto yy39;
		case '^': goto yy40;
		case '{': goto yy41;
		case '|': goto yy42;
		case '}': goto yy43;
		case '~': goto yy44;
		default: goto yy2;
	}
yy1:
	++YYCURSOR;
	{ if (eoi) { RET(TOKEN_EOI); } goto bad_chars; }
yy2:
	++YYCURSOR;
yy3:
	{ goto bad_chars; }
yy4:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '\n') {
		if (yych == '\t') goto yy4;
	} else {
		if (yych <= '\f') goto yy4;
		if (yych == ' ') goto yy4;
	}
	{ if (s->report_whitespace) { RET(' '); } goto scanner_loop; }
yy5:
	++YYCURSOR;
yy6:
	{ s->line++; RET('\n'); }
yy7:
	yych = *++YYCURSOR;
	if (yych == '\n') goto yy5;
	goto yy6;
yy8:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy45;
	{ RET('!'); }
yy9:
	++YYCURSOR;
	{ goto stringliteral; }
yy10:
	yych = *++YYCURSOR;
	if (yych == '#') goto yy46;
	{ RET(TOKEN_HASH); }
yy11:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy47;
	{ RET('%'); }
yy12:
	yych = *++YYCURSOR;
	if (yych == '&') goto yy48;
	if (yych == '=') goto yy49;
	{ RET('&'); }
yy13:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '\n') {
		if (yych <= 0x00) goto yy3;
		if (yych <= '\t') goto yy51;
		goto yy3;
	} else {
		if (yych == '\r') goto yy3;
		goto yy51;
	}
yy14:
	++YYCURSOR;
	{ RET('('); }
yy15:
	++YYCURSOR;
	{ RET(')'); }
yy16:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy55;
	{ RET('*'); }
yy17:
	yych = *++YYCURSOR;
	if (yych == '+') goto yy56;
	if (yych == '=') goto yy57;
	{ RET('+'); }
yy18:
	++YYCURSOR;
	{ RET(','); }
yy19:
	yych = *++YYCURSOR;
	if (yych == '-') goto yy58;
	if (yych == '=') goto yy59;
	{ RET('-'); }
yy20:
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy21;
	if (yych <= '9') goto yy60;
yy21:
	{ RET('.'); }
yy22:
	yych = *++YYCURSOR;
	if (yych <= '.') {
		if (yych == '*') goto yy62;
	} else {
		if (yych <= '/') goto yy63;
		if (yych == '=') goto yy64;
	}
	{ RET('/'); }
yy23:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'X') goto yy67;
	if (yych == 'x') goto yy67;
	goto yy26;
yy24:
	{ RET(TOKEN_INT_LITERAL); }
yy25:
	yyaccept = 1;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
yy26:
	if (yych <= 'L') {
		if (yych <= '9') {
			if (yych == '.') goto yy60;
			if (yych <= '/') goto yy24;
			goto yy25;
		} else {
			if (yych == 'E') goto yy65;
			if (yych <= 'K') goto yy24;
			goto yy66;
		}
	} else {
		if (yych <= 'e') {
			if (yych == 'U') goto yy66;
			if (yych <= 'd') goto yy24;
			goto yy65;
		} else {
			if (yych <= 'l') {
				if (yych <= 'k') goto yy24;
				goto yy66;
			} else {
				if (yych == 'u') goto yy66;
				goto yy24;
			}
		}
	}
yy27:
	++YYCURSOR;
	{ RET(':'); }
yy28:
	++YYCURSOR;
	{ if (s->asm_comments) { goto singlelinecomment; } RET(';'); }
yy29:
	yych = *++YYCURSOR;
	if (yych <= ';') goto yy30;
	if (yych <= '<') goto yy68;
	if (yych <= '=') goto yy69;
yy30:
	{ RET('<'); }
yy31:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy70;
	{ RET('='); }
yy32:
	yych = *++YYCURSOR;
	if (yych <= '<') goto yy33;
	if (yych <= '=') goto yy71;
	if (yych <= '>') goto yy72;
yy33:
	{ RET('>'); }
yy34:
	++YYCURSOR;
	{ RET('?'); }
yy35:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'Z') {
		if (yych <= '/') goto yy36;
		if (yych <= '9') goto yy35;
		if (yych >= 'A') goto yy35;
	} else {
		if (yych <= '_') {
			if (yych >= '_') goto yy35;
		} else {
			if (yych <= '`') goto yy36;
			if (yych <= 'z') goto yy35;
		}
	}
yy36:
	{ RET(TOKEN_IDENTIFIER); }
yy37:
	++YYCURSOR;
	{ RET('['); }
yy38:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x08) goto yy3;
	if (yych <= '\r') goto yy74;
	if (yych == ' ') goto yy74;
	goto yy3;
yy39:
	++YYCURSOR;
	{ RET(']'); }
yy40:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy78;
	{ RET('^'); }
yy41:
	++YYCURSOR;
	{ RET('{'); }
yy42:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy79;
	if (yych == '|') goto yy80;
	{ RET('|'); }
yy43:
	++YYCURSOR;
	{ RET('}'); }
yy44:
	++YYCURSOR;
	{ RET('~'); }
yy45:
	++YYCURSOR;
	{ RET(TOKEN_NEQ); }
yy46:
	++YYCURSOR;
	{ RET(TOKEN_HASHHASH); }
yy47:
	++YYCURSOR;
	{ RET(TOKEN_MODASSIGN); }
yy48:
	++YYCURSOR;
	{ RET(TOKEN_ANDAND); }
yy49:
	++YYCURSOR;
	{ RET(TOKEN_ANDASSIGN); }
yy50:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy51:
	if (yych <= '\r') {
		if (yych <= '\t') {
			if (yych >= 0x01) goto yy50;
		} else {
			if (yych <= '\n') goto yy52;
			if (yych <= '\f') goto yy50;
		}
	} else {
		if (yych <= '\'') {
			if (yych <= '&') goto yy50;
			goto yy53;
		} else {
			if (yych == '\\') goto yy54;
			goto yy50;
		}
	}
yy52:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 1) {
		if (yyaccept == 0) {
			goto yy3;
		} else {
			goto yy24;
		}
	} else {
		goto yy61;
	}
yy53:
	++YYCURSOR;
	goto yy24;
yy54:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'b') {
		if (yych <= '7') {
			if (yych <= '&') {
				if (yych == '"') goto yy50;
				goto yy52;
			} else {
				if (yych <= '\'') goto yy50;
				if (yych <= '/') goto yy52;
				goto yy50;
			}
		} else {
			if (yych <= '[') {
				if (yych == '?') goto yy50;
				goto yy52;
			} else {
				if (yych <= '\\') goto yy50;
				if (yych <= '`') goto yy52;
				goto yy50;
			}
		}
	} else {
		if (yych <= 'r') {
			if (yych <= 'm') {
				if (yych == 'f') goto yy50;
				goto yy52;
			} else {
				if (yych <= 'n') goto yy50;
				if (yych <= 'q') goto yy52;
				goto yy50;
			}
		} else {
			if (yych <= 'u') {
				if (yych == 't') goto yy50;
				goto yy52;
			} else {
				if (yych <= 'v') goto yy50;
				if (yych == 'x') goto yy81;
				goto yy52;
			}
		}
	}
yy55:
	++YYCURSOR;
	{ RET(TOKEN_MULTASSIGN); }
yy56:
	++YYCURSOR;
	{ RET(TOKEN_INCREMENT); }
yy57:
	++YYCURSOR;
	{ RET(TOKEN_ADDASSIGN); }
yy58:
	++YYCURSOR;
	{ RET(TOKEN_DECREMENT); }
yy59:
	++YYCURSOR;
	{ RET(TOKEN_SUBASSIGN); }
yy60:
	yyaccept = 2;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	if (yych <= 'G') {
		if (yych <= 'D') {
			if (yych <= '/') goto yy61;
			if (yych <= '9') goto yy60;
		} else {
			if (yych <= 'E') goto yy65;
			if (yych <= 'F') goto yy82;
		}
	} else {
		if (yych <= 'e') {
			if (yych <= 'H') goto yy82;
			if (yych >= 'e') goto yy65;
		} else {
			if (yych == 'g') goto yy61;
			if (yych <= 'h') goto yy82;
		}
	}
yy61:
	{ RET(TOKEN_FLOAT_LITERAL); }
yy62:
	++YYCURSOR;
	{ goto multilinecomment; }
yy63:
	++YYCURSOR;
	{ goto singlelinecomment; }
yy64:
	++YYCURSOR;
	{ RET(TOKEN_DIVASSIGN); }
yy65:
	yych = *++YYCURSOR;
	if (yych <= ',') {
		if (yych == '+') goto yy83;
		goto yy52;
	} else {
		if (yych <= '-') goto yy83;
		if (yych <= '/') goto yy52;
		if (yych <= '9') goto yy84;
		goto yy52;
	}
yy66:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'U') {
		if (yych == 'L') goto yy66;
		if (yych <= 'T') goto yy24;
		goto yy66;
	} else {
		if (yych <= 'l') {
			if (yych <= 'k') goto yy24;
			goto yy66;
		} else {
			if (yych == 'u') goto yy66;
			goto yy24;
		}
	}
yy67:
	yych = *++YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy52;
		if (yych <= '9') goto yy85;
		goto yy52;
	} else {
		if (yych <= 'F') goto yy85;
		if (yych <= '`') goto yy52;
		if (yych <= 'f') goto yy85;
		goto yy52;
	}
yy68:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy86;
	{ RET(TOKEN_LSHIFT); }
yy69:
	++YYCURSOR;
	{ RET(TOKEN_LEQ); }
yy70:
	++YYCURSOR;
	{ RET(TOKEN_EQL); }
yy71:
	++YYCURSOR;
	{ RET(TOKEN_GEQ); }
yy72:
	yych = *++YYCURSOR;
	if (yych == '=') goto yy87;
	{ RET(TOKEN_RSHIFT); }
yy73:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
yy74:
	if (yych <= '\f') {
		if (yych <= 0x08) goto yy52;
		if (yych != '\n') goto yy73;
	} else {
		if (yych <= '\r') goto yy77;
		if (yych == ' ') goto yy73;
		goto yy52;
	}
yy75:
	++YYCURSOR;
yy76:
	{ s->line++; goto scanner_loop; }
yy77:
	yych = *++YYCURSOR;
	if (yych == '\n') goto yy75;
	goto yy76;
yy78:
	++YYCURSOR;
	{ RET(TOKEN_XORASSIGN); }
yy79:
	++YYCURSOR;
	{ RET(TOKEN_ORASSIGN); }
yy80:
	++YYCURSOR;
	{ RET(TOKEN_OROR); }
yy81:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '@') {
		if (yych <= '/') goto yy52;
		if (yych <= '9') goto yy50;
		goto yy52;
	} else {
		if (yych <= 'F') goto yy50;
		if (yych <= '`') goto yy52;
		if (yych <= 'f') goto yy50;
		goto yy52;
	}
yy82:
	++YYCURSOR;
	goto yy61;
yy83:
	yych = *++YYCURSOR;
	if (yych <= '/') goto yy52;
	if (yych >= ':') goto yy52;
yy84:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'G') {
		if (yych <= '9') {
			if (yych <= '/') goto yy61;
			goto yy84;
		} else {
			if (yych == 'F') goto yy82;
			goto yy61;
		}
	} else {
		if (yych <= 'f') {
			if (yych <= 'H') goto yy82;
			if (yych <= 'e') goto yy61;
			goto yy82;
		} else {
			if (yych == 'h') goto yy82;
			goto yy61;
		}
	}
yy85:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 'T') {
		if (yych <= '@') {
			if (yych <= '/') goto yy24;
			if (yych <= '9') goto yy85;
			goto yy24;
		} else {
			if (yych <= 'F') goto yy85;
			if (yych == 'L') goto yy66;
			goto yy24;
		}
	} else {
		if (yych <= 'k') {
			if (yych <= 'U') goto yy66;
			if (yych <= '`') goto yy24;
			if (yych <= 'f') goto yy85;
			goto yy24;
		} else {
			if (yych <= 'l') goto yy66;
			if (yych == 'u') goto yy66;
			goto yy24;
		}
	}
yy86:
	++YYCURSOR;
	{ RET(TOKEN_LSHIFTASSIGN); }
yy87:
	++YYCURSOR;
	{ RET(TOKEN_RSHIFTASSIGN); }
}


stringliteral:
    /* !!! FIXME: forbid newlines in string literals? */
    /* !!! FIXME: the ANY section used to be `(ESC|ANY\[\r\n\\"])` ...is that redundant or was it like that for a reason? */
    if (YYLIMIT <= YYCURSOR) { YYFILL(1); }

{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= 0x00) goto yy89;
	if (yych == '"') goto yy91;
	goto yy90;
yy89:
	++YYCURSOR;
	{
                        if (eoi) {
                            RET(TOKEN_INCOMPLETE_STRING_LITERAL);
                        }
                        goto stringliteral;
                    }
yy90:
	++YYCURSOR;
	{ goto stringliteral; }
yy91:
	++YYCURSOR;
	{ RET(TOKEN_STRING_LITERAL); }
}


multilinecomment:
    if (YYLIMIT <= YYCURSOR) { YYFILL(1); }
    matchptr = cursor;
/* The "*\/" is just to avoid screwing up text editor syntax highlighting. */

{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych <= '\f') {
		if (yych <= 0x00) goto yy93;
		if (yych == '\n') goto yy96;
		goto yy94;
	} else {
		if (yych <= '\r') goto yy98;
		if (yych == '*') goto yy99;
		goto yy94;
	}
yy93:
	++YYCURSOR;
	{
                        if (eoi) {
                            RET(TOKEN_INCOMPLETE_COMMENT);
                        }
                        goto multilinecomment;
                    }
yy94:
	++YYCURSOR;
yy95:
	{ goto multilinecomment; }
yy96:
	++YYCURSOR;
yy97:
	{
                        s->line++;
                        goto multilinecomment;
                    }
yy98:
	yych = *++YYCURSOR;
	if (yych == '\n') goto yy96;
	goto yy97;
yy99:
	yych = *++YYCURSOR;
	if (yych != '/') goto yy95;
	++YYCURSOR;
	{ RET(TOKEN_MULTI_COMMENT); }
}


singlelinecomment:
    if (YYLIMIT <= YYCURSOR) { YYFILL(1); }
    matchptr = cursor;

{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych <= '\n') {
		if (yych <= 0x00) goto yy101;
		if (yych <= '\t') goto yy102;
		goto yy103;
	} else {
		if (yych == '\r') goto yy105;
		goto yy102;
	}
yy101:
	++YYCURSOR;
	{
                        cursor = matchptr;  // so we RET(TOKEN_EOI) next.
                        RET(TOKEN_SINGLE_COMMENT);
                    }
yy102:
	++YYCURSOR;
	{ goto singlelinecomment; }
yy103:
	++YYCURSOR;
yy104:
	{
                        cursor = matchptr;  // so we RET('\n') next.
                        RET(TOKEN_SINGLE_COMMENT);
                    }
yy105:
	yych = *++YYCURSOR;
	if (yych == '\n') goto yy103;
	goto yy104;
}


ppdirective:
    if (YYLIMIT <= YYCURSOR) { YYFILL(1); }

{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	if ((YYLIMIT - YYCURSOR) < 8) YYFILL(8);
	yych = *YYCURSOR;
	if (yych <= '\f') {
		if (yych <= 0x08) {
			if (yych >= 0x01) goto yy108;
		} else {
			if (yych == '\n') goto yy108;
			goto yy110;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy108;
			goto yy110;
		} else {
			if (yych == '#') goto yy111;
			goto yy108;
		}
	}
yy107:
	YYCURSOR = YYMARKER;
	if (yyaccept == 0) {
		goto yy109;
	} else {
		goto yy125;
	}
yy108:
	++YYCURSOR;
yy109:
	{
                            token = cursor = (const uchar *) s->source;
                            limit = cursor + s->bytes_left;
                            goto scanner_loop;
                        }
yy110:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '\n') {
		if (yych == '\t') goto yy110;
	} else {
		if (yych <= '\f') goto yy110;
		if (yych == ' ') goto yy110;
	}
	{ goto ppdirective; }
yy111:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'h') {
		if (yych <= 0x1F) {
			if (yych == '\t') goto yy113;
			goto yy109;
		} else {
			if (yych <= ' ') goto yy113;
			if (yych <= 'c') goto yy109;
			if (yych <= 'e') goto yy113;
			goto yy109;
		}
	} else {
		if (yych <= 'o') {
			if (yych <= 'i') goto yy113;
			if (yych == 'l') goto yy113;
			goto yy109;
		} else {
			if (yych <= 'p') goto yy113;
			if (yych == 'u') goto yy113;
			goto yy109;
		}
	}
yy112:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);
	yych = *YYCURSOR;
yy113:
	if (yych <= 'h') {
		if (yych <= ' ') {
			if (yych == '\t') goto yy112;
			if (yych <= 0x1F) goto yy107;
			goto yy112;
		} else {
			if (yych <= 'c') goto yy107;
			if (yych <= 'd') goto yy114;
			if (yych <= 'e') goto yy115;
			goto yy107;
		}
	} else {
		if (yych <= 'o') {
			if (yych <= 'i') goto yy116;
			if (yych == 'l') goto yy117;
			goto yy107;
		} else {
			if (yych <= 'p') goto yy118;
			if (yych == 'u') goto yy119;
			goto yy107;
		}
	}
yy114:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy120;
	goto yy107;
yy115:
	yych = *++YYCURSOR;
	if (yych <= 'm') {
		if (yych == 'l') goto yy121;
		goto yy107;
	} else {
		if (yych <= 'n') goto yy122;
		if (yych == 'r') goto yy123;
		goto yy107;
	}
yy116:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy124;
	if (yych == 'n') goto yy126;
	goto yy107;
yy117:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy127;
	goto yy107;
yy118:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy128;
	goto yy107;
yy119:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy129;
	goto yy107;
yy120:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy130;
	goto yy107;
yy121:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy131;
	if (yych == 's') goto yy132;
	goto yy107;
yy122:
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy133;
	goto yy107;
yy123:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy134;
	goto yy107;
yy124:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == 'd') goto yy135;
	if (yych == 'n') goto yy136;
yy125:
	{ RET(TOKEN_PP_IF); }
yy126:
	yych = *++YYCURSOR;
	if (yych == 'c') goto yy137;
	goto yy107;
yy127:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy138;
	goto yy107;
yy128:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy139;
	goto yy107;
yy129:
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy140;
	goto yy107;
yy130:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy141;
	goto yy107;
yy131:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy142;
	goto yy107;
yy132:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy143;
	goto yy107;
yy133:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy144;
	goto yy107;
yy134:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy145;
	goto yy107;
yy135:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy146;
	goto yy107;
yy136:
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy147;
	goto yy107;
yy137:
	yych = *++YYCURSOR;
	if (yych == 'l') goto yy148;
	goto yy107;
yy138:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy149;
	goto yy107;
yy139:
	yych = *++YYCURSOR;
	if (yych == 'g') goto yy150;
	goto yy107;
yy140:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy151;
	goto yy107;
yy141:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy152;
	goto yy107;
yy142:
	++YYCURSOR;
	{ RET(TOKEN_PP_ELIF); }
yy143:
	++YYCURSOR;
	{ RET(TOKEN_PP_ELSE); }
yy144:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy153;
	goto yy107;
yy145:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy154;
	goto yy107;
yy146:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy155;
	goto yy107;
yy147:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy156;
	goto yy107;
yy148:
	yych = *++YYCURSOR;
	if (yych == 'u') goto yy157;
	goto yy107;
yy149:
	++YYCURSOR;
	{ RET(TOKEN_PP_LINE); }
yy150:
	yych = *++YYCURSOR;
	if (yych == 'm') goto yy158;
	goto yy107;
yy151:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy159;
	goto yy107;
yy152:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy160;
	goto yy107;
yy153:
	++YYCURSOR;
	{ RET(TOKEN_PP_ENDIF); }
yy154:
	++YYCURSOR;
	{ RET(TOKEN_PP_ERROR); }
yy155:
	++YYCURSOR;
	{ RET(TOKEN_PP_IFDEF); }
yy156:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy161;
	goto yy107;
yy157:
	yych = *++YYCURSOR;
	if (yych == 'd') goto yy162;
	goto yy107;
yy158:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy163;
	goto yy107;
yy159:
	++YYCURSOR;
	{ RET(TOKEN_PP_UNDEF); }
yy160:
	++YYCURSOR;
	{ RET(TOKEN_PP_DEFINE); }
yy161:
	++YYCURSOR;
	{ RET(TOKEN_PP_IFNDEF); }
yy162:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy164;
	goto yy107;
yy163:
	++YYCURSOR;
	{ RET(TOKEN_PP_PRAGMA); }
yy164:
	++YYCURSOR;
	{ RET(TOKEN_PP_INCLUDE); }
}


bad_chars:
    if (YYLIMIT <= YYCURSOR) { YYFILL(1); }

{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '#') {
		if (yych <= '\r') {
			if (yych <= 0x00) goto yy166;
			if (yych <= 0x08) goto yy167;
			goto yy168;
		} else {
			if (yych <= 0x1F) goto yy167;
			if (yych == '"') goto yy167;
			goto yy168;
		}
	} else {
		if (yych <= '@') {
			if (yych <= '$') goto yy167;
			if (yych <= '?') goto yy168;
			goto yy167;
		} else {
			if (yych == '`') goto yy167;
			if (yych <= '~') goto yy168;
			goto yy167;
		}
	}
yy166:
	++YYCURSOR;
	{
                        if (eoi)
                        {
                            SDL_assert( !((token >= sentinel) && (token < sentinel+YYMAXFILL)) );
                            eoi = 0;
                            cursor = (uchar *) s->source_base + s->orig_length;
                            RET(TOKEN_BAD_CHARS);  // next call will be EOI.
                        }
                        goto bad_chars;
                    }
yy167:
	++YYCURSOR;
	{ goto bad_chars; }
yy168:
	++YYCURSOR;
	{ cursor--; RET(TOKEN_BAD_CHARS); }
}


    SDL_assert(0 && "Shouldn't hit this code");
    RET(TOKEN_UNKNOWN);
}

/* end of SDL_shader_lexer.re (or .c) ... */

